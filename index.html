<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Low‑Poly Forest Shooter</title>
  <style>
    html, body { height: 100%; margin: 0; overflow: hidden; background: #202428; }
    #app { position: fixed; inset: 0; }
    canvas { display: block; }
    .ui {
      position: fixed; left: 50%; transform: translateX(-50%);
      bottom: 16px; padding: 10px 14px; border-radius: 14px;
      background: rgba(20,22,24,0.65); color: #e9eef5; font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      box-shadow: 0 6px 24px rgba(0,0,0,0.35); backdrop-filter: blur(6px);
      user-select: none; pointer-events: none;
    }
    .ui b { color: #fff; }
    .crosshair {
      position: fixed; left: 50%; top: 50%; transform: translate(-50%, -50%);
      width: 14px; height: 14px; pointer-events: none; opacity: 0.85;
    }
    .crosshair:before, .crosshair:after {
      content: ""; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%);
      background: #e9eef5; border-radius: 2px;
    }
    .crosshair:before { width: 14px; height: 2px; }
    .crosshair:after  { width: 2px; height: 14px; }
    .hint {
      position: fixed; top: 16px; left: 50%; transform: translateX(-50%);
      padding: 10px 14px; border-radius: 14px; color: #f1f5f9;
      background: rgba(0,0,0,0.45); backdrop-filter: blur(4px);
      font: 13px/1.3 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      box-shadow: 0 6px 24px rgba(0,0,0,0.35);
      text-align: center;
    }
    .hidden { display: none; }
    #settings {
      position: fixed; top: 16px; right: 16px;
      padding: 10px 14px; border-radius: 14px;
      background: rgba(20,22,24,0.65); color: #e9eef5; font: 14px/1.4 system-ui,-apple-system, Segoe UI, Roboto, sans-serif;
      box-shadow: 0 6px 24px rgba(0,0,0,0.35); backdrop-filter: blur(6px);
    }
    #settings label { display: block; margin-bottom: 4px; }
    #settings input { width: 160px; }
  </style>
</head>
<body>
  <div id="app"></div>
  <div class="crosshair"></div>
  <div class="hint" id="hint">Middle‑click to lock the mouse. <b>WASD</b> to move, <b>Mouse</b> to aim, <b>Left Click</b> to shoot, <b>Space</b> to jump.</div>
  <div class="ui">Low‑poly forest • third‑person shooter vibe (generic character, Fortnite‑style POV)</div>
  <div id="settings">
    <label>Balls: <span id="ballCountLabel">2000</span></label>
    <input type="range" id="ballCount" min="100" max="10000" value="2000">
  </div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.158.0/build/three.module.js';

    // --- Renderer & Scene ---
    const app = document.getElementById('app');
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(innerWidth, innerHeight);
    renderer.shadowMap.enabled = true;
    app.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x7fb0ff);
    scene.fog = new THREE.Fog(0x7fb0ff, 20, 140);

    // --- Camera (third‑person follow) ---
    const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.1, 500);

    // --- Lights ---
    const hemi = new THREE.HemisphereLight(0xffffff, 0x335533, 0.6);
    scene.add(hemi);

    const sun = new THREE.DirectionalLight(0xffffff, 1.0);
    sun.position.set(40, 60, 20);
    sun.castShadow = true;
    sun.shadow.mapSize.set(2048, 2048);
    sun.shadow.camera.near = 1;
    sun.shadow.camera.far = 200;
    sun.shadow.camera.left = -80;
    sun.shadow.camera.right = 80;
    sun.shadow.camera.top = 80;
    sun.shadow.camera.bottom = -80;
    scene.add(sun);

    // --- Ground ---
    const groundSize = 240;
    const groundGeo = new THREE.PlaneGeometry(groundSize, groundSize, 1, 1);
    const groundMat = new THREE.MeshLambertMaterial({ color: 0x6dbb4b }); // grassy green
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI/2;
    ground.receiveShadow = true;
    scene.add(ground);

    // --- Low‑poly Tree Factory ---
    function makeTree() {
      const group = new THREE.Group();
      const trunk = new THREE.Mesh(
        new THREE.CylinderGeometry(0.25, 0.35, 2.5, 6),
        new THREE.MeshLambertMaterial({ color: 0x8b5a2b })
      );
      trunk.castShadow = true; trunk.receiveShadow = true;
      trunk.position.y = 1.25;

      const foliage = new THREE.Mesh(
        new THREE.ConeGeometry(1.6, 3.2, 6),
        new THREE.MeshLambertMaterial({ color: 0x2f8f46 })
      );
      foliage.castShadow = true; foliage.receiveShadow = true;
      foliage.position.y = 1.25 + 1.6;

      const cap = new THREE.Mesh(
        new THREE.ConeGeometry(1.2, 2.2, 6),
        new THREE.MeshLambertMaterial({ color: 0x2a7a3d })
      );
      cap.castShadow = true; cap.receiveShadow = true;
      cap.position.y = foliage.position.y + 1.1;

      group.add(trunk, foliage, cap);
      return group;
    }

    // Scatter trees but keep a clearing near the spawn
    const rng = (min,max)=>Math.random()*(max-min)+min;
    const trees = [];
    for (let i=0;i<220;i++){
      const t = makeTree();
      const r = groundSize*0.48;
      let x, z; let tries = 0;
      do {
        x = rng(-r, r); z = rng(-r, r); tries++;
      } while (tries < 50 && Math.hypot(x, z) < 12); // keep spawn clearing
      t.position.set(x, 0, z);
      t.rotation.y = rng(0, Math.PI*2);
      const s = rng(0.8, 1.4); t.scale.setScalar(s);
      trees.push(t);
      scene.add(t);
    }

    // --- Player (generic low‑poly, Fortnite‑inspired POV) ---
    const player = new THREE.Group();

    // Body parts
    const body = new THREE.Mesh(new THREE.BoxGeometry(0.9, 1.2, 0.5), new THREE.MeshLambertMaterial({ color: 0x3b82f6 }));
    body.position.y = 1.1; body.castShadow = true; body.receiveShadow = true;

    const head = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), new THREE.MeshLambertMaterial({ color: 0xf1f5f9 }));
    head.position.y = 1.1 + 0.85; head.castShadow = true;

    const legL = new THREE.Mesh(new THREE.BoxGeometry(0.35, 0.9, 0.35), new THREE.MeshLambertMaterial({ color: 0x1f2937 }));
    const legR = legL.clone();
    legL.position.set(-0.22, 0.45, 0);
    legR.position.set( 0.22, 0.45, 0);

    const armL = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.9, 0.25), new THREE.MeshLambertMaterial({ color: 0x3b82f6 }));
    const armR = armL.clone();
    armL.position.set(-0.6, 1.2, 0);
    armR.position.set( 0.6, 1.2, 0);

    // Simple blaster
    const gun = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.2, 0.2), new THREE.MeshLambertMaterial({ color: 0x111315 }));
    gun.castShadow = true; gun.position.set(0.55, 1.25, -0.12);
    armR.add(gun);

    player.add(body, head, legL, legR, armL, armR);
    player.position.set(0, 0, 0);
    scene.add(player);

    // --- Scary Rabbit ---
    function makeScaryRabbit() {
      const g = new THREE.Group();
      const body = new THREE.Mesh(
        new THREE.SphereGeometry(1.2, 16, 16),
        new THREE.MeshLambertMaterial({ color: 0xffffff })
      );
      body.position.y = 1.2; body.castShadow = true; body.receiveShadow = true;

      const head = new THREE.Mesh(
        new THREE.SphereGeometry(0.8, 16, 16),
        new THREE.MeshLambertMaterial({ color: 0xffffff })
      );
      head.position.y = 2.1; head.castShadow = true;

      const earGeo = new THREE.BoxGeometry(0.3, 1.2, 0.3);
      const earMat = new THREE.MeshLambertMaterial({ color: 0xffffff });
      const earL = new THREE.Mesh(earGeo, earMat);
      earL.position.set(-0.35, 2.8, 0); earL.castShadow = true;
      const earR = earL.clone(); earR.position.x = 0.35;

      const eyeGeo = new THREE.SphereGeometry(0.12, 8, 8);
      const eyeMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
      const eyeL = new THREE.Mesh(eyeGeo, eyeMat); eyeL.position.set(-0.2, 2.2, 0.55);
      const eyeR = eyeL.clone(); eyeR.position.x = 0.2;

      const blood = new THREE.Mesh(
        new THREE.PlaneGeometry(1.4, 0.6),
        new THREE.MeshBasicMaterial({ color: 0x8b0000 })
      );
      blood.rotation.x = -Math.PI/2; blood.position.set(0, 0, -0.8);

      g.add(body, head, earL, earR, eyeL, eyeR, blood);
      g.scale.set(2.2, 2.2, 2.2);
      return g;
    }

    const rabbit = makeScaryRabbit();
    let rabbitVisible = false;

    function spawnRabbit() {
      const candidates = trees.filter(t => {
        const d = t.position.distanceTo(player.position);
        return d > 15 && d < 45;
      });
      if (candidates.length === 0) return;
      const tree = candidates[Math.floor(Math.random() * candidates.length)];
      const away = player.position.clone().sub(tree.position).normalize();
      rabbit.position.copy(tree.position.clone().add(away.multiplyScalar(-2.2)));
      scene.add(rabbit);
      rabbitVisible = true;
    }

    spawnRabbit();

    // --- Controls state ---
    let yaw = 0; // horizontal aim
    let pitch = 0; // vertical aim (for camera only)
    const keys = new Set();
    let pointerLocked = false;

    // Camera offset relative to player in local space (over‑the‑shoulder)
    const camOffset = new THREE.Vector3(-2.5, 1.8, 3.8); // left shoulder & back

    // --- Bullets ---
    const bullets = [];
    const bulletGeo = new THREE.SphereGeometry(0.1, 12, 8);
    const bulletMat = new THREE.MeshBasicMaterial({ color: 0xffffee });

    const ballSlider = document.getElementById('ballCount');
    const ballLabel = document.getElementById('ballCountLabel');
    let ballLimit = parseInt(ballSlider.value,10);
    ballSlider.addEventListener('input', ()=>{
      ballLimit = parseInt(ballSlider.value,10);
      ballLabel.textContent = ballLimit;
    });
    let totalDispensed = 0;

    const dispensers = [];
    function makeDispenser(pos){
      const geo = new THREE.BoxGeometry(0.6,0.6,0.6);
      const mat = new THREE.MeshLambertMaterial({ color: 0xffaa00 });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.position.copy(pos);
      mesh.castShadow = true; mesh.receiveShadow = true;
      scene.add(mesh);
      return {mesh, lastShot:0};
    }
    dispensers.push(makeDispenser(new THREE.Vector3(5,0.3,5)));
    dispensers.push(makeDispenser(new THREE.Vector3(-5,0.3,-5)));

    const balls = [];
    const ballGeo = new THREE.SphereGeometry(0.5,16,12);
    const ballMat = new THREE.MeshLambertMaterial({ color: 0x6699ff });

    function spawnBall(d){
      const mesh = new THREE.Mesh(ballGeo, ballMat.clone());
      mesh.position.copy(d.mesh.position);
      mesh.castShadow = true; mesh.receiveShadow = true;
      const dir = new THREE.Vector3(Math.random()-0.5, Math.random()*0.5+0.2, Math.random()-0.5).normalize();
      const vel = dir.multiplyScalar(6);
      balls.push({mesh, vel, scale:1});
      scene.add(mesh);
    }

    const bouncers = [];
    function makeBouncer(pos, radius){
      const geo = new THREE.SphereGeometry(radius,16,12);
      const mat = new THREE.MeshLambertMaterial({ color: 0xff4444 });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.position.copy(pos);
      mesh.castShadow = true; mesh.receiveShadow = true;
      scene.add(mesh);
      bouncers.push({mesh, radius});
    }
    makeBouncer(new THREE.Vector3(0,1,0), 1.5);

    function shoot(){
      // Muzzle position slightly in front/right of player chest, aligned with aim
      const muzzle = new THREE.Vector3(0.4, 1.3, -0.2);
      const muzzleWorld = player.localToWorld(muzzle.clone());

      // Forward direction from camera (aim)
      const dir = new THREE.Vector3();
      camera.getWorldDirection(dir);

      const mesh = new THREE.Mesh(bulletGeo, bulletMat);
      mesh.position.copy(muzzleWorld);
      scene.add(mesh);

      bullets.push({ mesh, vel: dir.multiplyScalar(38), born: performance.now() });
    }

    // --- Input ---
    addEventListener('keydown', e=>{ keys.add(e.code); });
    addEventListener('keyup',   e=>{ keys.delete(e.code); });

    // Pointer lock for mouse look
    const hint = document.getElementById('hint');
    addEventListener('mousedown', (e) => {
      if (e.button === 1 && !pointerLocked) {
        // middle mouse initiates pointer lock
        renderer.domElement.requestPointerLock();
        e.preventDefault();
      } else if (e.button === 0 && pointerLocked) {
        // left click while locked shoots
        shoot();
      }
    });

    document.addEventListener('pointerlockchange', () => {
      pointerLocked = document.pointerLockElement === renderer.domElement;
      hint.classList.toggle('hidden', pointerLocked);
    });

    addEventListener('mousemove', e=>{
      if(!pointerLocked) return;
      const sensitivity = 0.0027;
      yaw   -= e.movementX * sensitivity;
      pitch -= e.movementY * sensitivity;
      pitch = Math.max(-Math.PI/3, Math.min(Math.PI/3, pitch));
    });

    // --- Movement & simple ground physics ---
    let velY = 0; // vertical velocity for jumping/gravity
    const GRAV = 22;

    function update(dt){
      // Move on XZ using yaw (aim direction)
      const speed = (keys.has('ShiftLeft')||keys.has('ShiftRight')) ? 10 : 6;
      const forward = new THREE.Vector3(-Math.sin(yaw), 0, -Math.cos(yaw));
      const right   = new THREE.Vector3(Math.cos(yaw), 0, -Math.sin(yaw));
      let move = new THREE.Vector3();
      if (keys.has('KeyW')) move.add(forward);
      if (keys.has('KeyS')) move.add(forward.clone().multiplyScalar(-1));
      if (keys.has('KeyD')) move.add(right);
      if (keys.has('KeyA')) move.add(right.clone().multiplyScalar(-1));
      if (move.lengthSq()>0) move.normalize().multiplyScalar(speed*dt);

      player.position.add(move);

      // Jump
      const onGround = player.position.y <= 0.0 + 0.001;
      if (onGround) { player.position.y = 0; velY = 0; }
      if (onGround && keys.has('Space')) velY = 7.5;
      velY -= GRAV * dt;
      player.position.y += velY * dt;
      if (player.position.y < 0) { player.position.y = 0; velY = 0; }

      // Rotate player body to face yaw (torso only for a simple look)
      player.rotation.y = yaw;

      // Aim the right arm toward where camera looks (rough)
      armR.rotation.x = -pitch * 0.75;

      // Update camera behind/over shoulder
      const q = new THREE.Quaternion().setFromEuler(new THREE.Euler(0, yaw, 0));
      const offsetWorld = camOffset.clone().applyQuaternion(q);
      const camPos = player.position.clone().add(offsetWorld);
      camera.position.lerp(camPos, 0.85); // smoothed

      // Camera look target slightly above player
      const lookTarget = player.position.clone().add(new THREE.Vector3(0, 1.3, 0));
      const targetDir = lookTarget.clone().sub(camera.position).normalize();

      // Apply pitch around player's right vector
      const rightVec = new THREE.Vector3().crossVectors(new THREE.Vector3(0,1,0), targetDir).normalize();
      const pitched = targetDir.clone().applyAxisAngle(rightVec, pitch);
      const camAim = camera.position.clone().add(pitched);
      camera.lookAt(camAim);

      // Bullets update
      const now = performance.now();
      for (let i=bullets.length-1;i>=0;i--){
        const b = bullets[i];
        b.mesh.position.addScaledVector(b.vel, dt);
        const life = (now - b.born) / 3000;
        b.mesh.scale.setScalar(Math.max(0, 1 - life));
        // remove old or out-of-bounds bullets
        if (life > 1 || b.mesh.position.length() > groundSize) {
          scene.remove(b.mesh); bullets.splice(i,1);
        }
      }

      // Dispensers shoot balls
      for (const d of dispensers){
        if (totalDispensed < ballLimit && now - d.lastShot > 1000){
          spawnBall(d);
          d.lastShot = now;
          totalDispensed++;
        }
      }

      // Balls update and interactions
      for (let i=balls.length-1;i>=0;i--){
        const ball = balls[i];
        ball.mesh.position.addScaledVector(ball.vel, dt);
        if (ball.mesh.position.y < 0.5){
          ball.mesh.position.y = 0.5;
          ball.vel.y = Math.abs(ball.vel.y);
        }
        for (const bn of bouncers){
          const dist = ball.mesh.position.distanceTo(bn.mesh.position);
          const minDist = bn.radius + 0.5*ball.scale;
          if (dist < minDist){
            const normal = ball.mesh.position.clone().sub(bn.mesh.position).normalize();
            ball.vel.reflect(normal);
            ball.mesh.position.add(normal.multiplyScalar(minDist - dist));
          }
        }
        for (let j=bullets.length-1;j>=0;j--){
          const b = bullets[j];
          const rad = 0.5*ball.scale + 0.1;
          if (ball.mesh.position.distanceTo(b.mesh.position) < rad){
            ball.scale *= 0.7;
            ball.mesh.scale.setScalar(ball.scale);
            scene.remove(b.mesh); bullets.splice(j,1);
            if (ball.scale < 0.15){
              scene.remove(ball.mesh); balls.splice(i,1);
            }
            break;
          }
        }
        if (ball.mesh.position.length() > groundSize){
          scene.remove(ball.mesh); balls.splice(i,1);
        }
      }

      // Remove rabbit if looked at
      if (rabbitVisible) {
        const camDir = new THREE.Vector3();
        camera.getWorldDirection(camDir);
        const toRabbit = rabbit.position.clone().sub(camera.position).normalize();
        if (camDir.angleTo(toRabbit) < 0.3) {
          scene.remove(rabbit);
          rabbitVisible = false;
        }
      }
    }

    // --- Animate ---
    let last = performance.now();
    function animate(){
      const now = performance.now();
      const dt = Math.min(0.033, (now - last)/1000);
      last = now;
      update(dt);
      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }

    // Spawn position and initial camera placement
    player.position.set(0,0,8);
    camera.position.set(-2.5, 2.2, 12);
    camera.lookAt(player.position.x, 1.3, player.position.z);

    // Resize
    addEventListener('resize', ()=>{
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    animate();
  </script>
</body>
</html>
